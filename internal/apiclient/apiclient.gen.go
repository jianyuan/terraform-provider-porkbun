// Package apiclient provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package apiclient

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/oapi-codegen/runtime"
)

// Defines values for DomainListAllJSONBodyIncludeLabels.
const (
	Yes DomainListAllJSONBodyIncludeLabels = "yes"
)

// ApiKeyAndSecretKey defines model for ApiKeyAndSecretKey.
type ApiKeyAndSecretKey struct {
	Apikey       string `json:"apikey"`
	Secretapikey string `json:"secretapikey"`
}

// BoolInteger defines model for BoolInteger.
type BoolInteger = int

// BoolString defines model for BoolString.
type BoolString = string

// DnsRecord defines model for DnsRecord.
type DnsRecord struct {
	Content string  `json:"content"`
	Id      string  `json:"id"`
	Name    string  `json:"name"`
	Notes   *string `json:"notes"`
	Prio    *string `json:"prio"`
	Ttl     string  `json:"ttl"`
	Type    string  `json:"type"`
}

// Domain defines model for Domain.
type Domain struct {
	AutoRenew  Domain_AutoRenew `json:"autoRenew"`
	CreateDate string           `json:"createDate"`
	Domain     string           `json:"domain"`
	ExpireDate string           `json:"expireDate"`
	Labels     []struct {
		Color string `json:"color"`
		Id    string `json:"id"`
		Title string `json:"title"`
	} `json:"labels"`
	NotLocal     Domain_NotLocal     `json:"notLocal"`
	SecurityLock Domain_SecurityLock `json:"securityLock"`
	Status       string              `json:"status"`
	Tld          string              `json:"tld"`
	WhoisPrivacy Domain_WhoisPrivacy `json:"whoisPrivacy"`
}

// Domain_AutoRenew defines model for Domain.AutoRenew.
type Domain_AutoRenew struct {
	union json.RawMessage
}

// Domain_NotLocal defines model for Domain.NotLocal.
type Domain_NotLocal struct {
	union json.RawMessage
}

// Domain_SecurityLock defines model for Domain.SecurityLock.
type Domain_SecurityLock struct {
	union json.RawMessage
}

// Domain_WhoisPrivacy defines model for Domain.WhoisPrivacy.
type Domain_WhoisPrivacy struct {
	union json.RawMessage
}

// DomainGetNameServersResponse defines model for DomainGetNameServersResponse.
type DomainGetNameServersResponse struct {
	Ns     []string `json:"ns"`
	Status string   `json:"status"`
}

// DomainListAllResponse defines model for DomainListAllResponse.
type DomainListAllResponse struct {
	Domains []Domain `json:"domains"`
	Status  string   `json:"status"`
}

// DomainPath defines model for domainPath.
type DomainPath = string

// DnsCreateRecordJSONBody defines parameters for DnsCreateRecord.
type DnsCreateRecordJSONBody struct {
	Apikey       string  `json:"apikey"`
	Content      string  `json:"content"`
	Name         *string `json:"name,omitempty"`
	Prio         *string `json:"prio,omitempty"`
	Secretapikey string  `json:"secretapikey"`
	Ttl          *string `json:"ttl,omitempty"`
	Type         string  `json:"type"`
}

// DnsEditRecordByDomainAndIdJSONBody defines parameters for DnsEditRecordByDomainAndId.
type DnsEditRecordByDomainAndIdJSONBody struct {
	Apikey       string  `json:"apikey"`
	Content      string  `json:"content"`
	Name         *string `json:"name,omitempty"`
	Prio         *string `json:"prio,omitempty"`
	Secretapikey string  `json:"secretapikey"`
	Ttl          *string `json:"ttl,omitempty"`
	Type         string  `json:"type"`
}

// DomainListAllJSONBody defines parameters for DomainListAll.
type DomainListAllJSONBody struct {
	Apikey        string                              `json:"apikey"`
	IncludeLabels *DomainListAllJSONBodyIncludeLabels `json:"includeLabels,omitempty"`
	Secretapikey  string                              `json:"secretapikey"`
	Start         *int                                `json:"start,omitempty"`
}

// DomainListAllJSONBodyIncludeLabels defines parameters for DomainListAll.
type DomainListAllJSONBodyIncludeLabels string

// DomainUpdateNameServersJSONBody defines parameters for DomainUpdateNameServers.
type DomainUpdateNameServersJSONBody struct {
	Apikey       string   `json:"apikey"`
	Ns           []string `json:"ns"`
	Secretapikey string   `json:"secretapikey"`
}

// DnsCreateRecordJSONRequestBody defines body for DnsCreateRecord for application/json ContentType.
type DnsCreateRecordJSONRequestBody DnsCreateRecordJSONBody

// DnsDeleteRecordByDomainAndIdJSONRequestBody defines body for DnsDeleteRecordByDomainAndId for application/json ContentType.
type DnsDeleteRecordByDomainAndIdJSONRequestBody = ApiKeyAndSecretKey

// DnsEditRecordByDomainAndIdJSONRequestBody defines body for DnsEditRecordByDomainAndId for application/json ContentType.
type DnsEditRecordByDomainAndIdJSONRequestBody DnsEditRecordByDomainAndIdJSONBody

// DnsRetrieveRecordsByDomainJSONRequestBody defines body for DnsRetrieveRecordsByDomain for application/json ContentType.
type DnsRetrieveRecordsByDomainJSONRequestBody = ApiKeyAndSecretKey

// DnsRetrieveRecordsByDomainAndIdJSONRequestBody defines body for DnsRetrieveRecordsByDomainAndId for application/json ContentType.
type DnsRetrieveRecordsByDomainAndIdJSONRequestBody = ApiKeyAndSecretKey

// DnsRetrieveRecordsByDomainAndTypeJSONRequestBody defines body for DnsRetrieveRecordsByDomainAndType for application/json ContentType.
type DnsRetrieveRecordsByDomainAndTypeJSONRequestBody = ApiKeyAndSecretKey

// DnsRetrieveRecordsByDomainAndTypeAndSubdomainJSONRequestBody defines body for DnsRetrieveRecordsByDomainAndTypeAndSubdomain for application/json ContentType.
type DnsRetrieveRecordsByDomainAndTypeAndSubdomainJSONRequestBody = ApiKeyAndSecretKey

// DomainGetNameServersJSONRequestBody defines body for DomainGetNameServers for application/json ContentType.
type DomainGetNameServersJSONRequestBody = ApiKeyAndSecretKey

// DomainListAllJSONRequestBody defines body for DomainListAll for application/json ContentType.
type DomainListAllJSONRequestBody DomainListAllJSONBody

// DomainUpdateNameServersJSONRequestBody defines body for DomainUpdateNameServers for application/json ContentType.
type DomainUpdateNameServersJSONRequestBody DomainUpdateNameServersJSONBody

// AsBoolInteger returns the union data inside the Domain_AutoRenew as a BoolInteger
func (t Domain_AutoRenew) AsBoolInteger() (BoolInteger, error) {
	var body BoolInteger
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBoolInteger overwrites any union data inside the Domain_AutoRenew as the provided BoolInteger
func (t *Domain_AutoRenew) FromBoolInteger(v BoolInteger) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBoolInteger performs a merge with any union data inside the Domain_AutoRenew, using the provided BoolInteger
func (t *Domain_AutoRenew) MergeBoolInteger(v BoolInteger) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsBoolString returns the union data inside the Domain_AutoRenew as a BoolString
func (t Domain_AutoRenew) AsBoolString() (BoolString, error) {
	var body BoolString
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBoolString overwrites any union data inside the Domain_AutoRenew as the provided BoolString
func (t *Domain_AutoRenew) FromBoolString(v BoolString) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBoolString performs a merge with any union data inside the Domain_AutoRenew, using the provided BoolString
func (t *Domain_AutoRenew) MergeBoolString(v BoolString) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Domain_AutoRenew) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Domain_AutoRenew) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsBoolInteger returns the union data inside the Domain_NotLocal as a BoolInteger
func (t Domain_NotLocal) AsBoolInteger() (BoolInteger, error) {
	var body BoolInteger
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBoolInteger overwrites any union data inside the Domain_NotLocal as the provided BoolInteger
func (t *Domain_NotLocal) FromBoolInteger(v BoolInteger) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBoolInteger performs a merge with any union data inside the Domain_NotLocal, using the provided BoolInteger
func (t *Domain_NotLocal) MergeBoolInteger(v BoolInteger) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsBoolString returns the union data inside the Domain_NotLocal as a BoolString
func (t Domain_NotLocal) AsBoolString() (BoolString, error) {
	var body BoolString
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBoolString overwrites any union data inside the Domain_NotLocal as the provided BoolString
func (t *Domain_NotLocal) FromBoolString(v BoolString) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBoolString performs a merge with any union data inside the Domain_NotLocal, using the provided BoolString
func (t *Domain_NotLocal) MergeBoolString(v BoolString) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Domain_NotLocal) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Domain_NotLocal) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsBoolInteger returns the union data inside the Domain_SecurityLock as a BoolInteger
func (t Domain_SecurityLock) AsBoolInteger() (BoolInteger, error) {
	var body BoolInteger
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBoolInteger overwrites any union data inside the Domain_SecurityLock as the provided BoolInteger
func (t *Domain_SecurityLock) FromBoolInteger(v BoolInteger) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBoolInteger performs a merge with any union data inside the Domain_SecurityLock, using the provided BoolInteger
func (t *Domain_SecurityLock) MergeBoolInteger(v BoolInteger) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsBoolString returns the union data inside the Domain_SecurityLock as a BoolString
func (t Domain_SecurityLock) AsBoolString() (BoolString, error) {
	var body BoolString
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBoolString overwrites any union data inside the Domain_SecurityLock as the provided BoolString
func (t *Domain_SecurityLock) FromBoolString(v BoolString) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBoolString performs a merge with any union data inside the Domain_SecurityLock, using the provided BoolString
func (t *Domain_SecurityLock) MergeBoolString(v BoolString) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Domain_SecurityLock) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Domain_SecurityLock) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsBoolInteger returns the union data inside the Domain_WhoisPrivacy as a BoolInteger
func (t Domain_WhoisPrivacy) AsBoolInteger() (BoolInteger, error) {
	var body BoolInteger
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBoolInteger overwrites any union data inside the Domain_WhoisPrivacy as the provided BoolInteger
func (t *Domain_WhoisPrivacy) FromBoolInteger(v BoolInteger) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBoolInteger performs a merge with any union data inside the Domain_WhoisPrivacy, using the provided BoolInteger
func (t *Domain_WhoisPrivacy) MergeBoolInteger(v BoolInteger) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsBoolString returns the union data inside the Domain_WhoisPrivacy as a BoolString
func (t Domain_WhoisPrivacy) AsBoolString() (BoolString, error) {
	var body BoolString
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBoolString overwrites any union data inside the Domain_WhoisPrivacy as the provided BoolString
func (t *Domain_WhoisPrivacy) FromBoolString(v BoolString) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBoolString performs a merge with any union data inside the Domain_WhoisPrivacy, using the provided BoolString
func (t *Domain_WhoisPrivacy) MergeBoolString(v BoolString) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Domain_WhoisPrivacy) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Domain_WhoisPrivacy) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// DnsCreateRecordWithBody request with any body
	DnsCreateRecordWithBody(ctx context.Context, domain DomainPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DnsCreateRecord(ctx context.Context, domain DomainPath, body DnsCreateRecordJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DnsDeleteRecordByDomainAndIdWithBody request with any body
	DnsDeleteRecordByDomainAndIdWithBody(ctx context.Context, domain DomainPath, recordId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DnsDeleteRecordByDomainAndId(ctx context.Context, domain DomainPath, recordId string, body DnsDeleteRecordByDomainAndIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DnsEditRecordByDomainAndIdWithBody request with any body
	DnsEditRecordByDomainAndIdWithBody(ctx context.Context, domain DomainPath, recordId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DnsEditRecordByDomainAndId(ctx context.Context, domain DomainPath, recordId string, body DnsEditRecordByDomainAndIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DnsRetrieveRecordsByDomainWithBody request with any body
	DnsRetrieveRecordsByDomainWithBody(ctx context.Context, domain DomainPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DnsRetrieveRecordsByDomain(ctx context.Context, domain DomainPath, body DnsRetrieveRecordsByDomainJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DnsRetrieveRecordsByDomainAndIdWithBody request with any body
	DnsRetrieveRecordsByDomainAndIdWithBody(ctx context.Context, domain DomainPath, recordId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DnsRetrieveRecordsByDomainAndId(ctx context.Context, domain DomainPath, recordId string, body DnsRetrieveRecordsByDomainAndIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DnsRetrieveRecordsByDomainAndTypeWithBody request with any body
	DnsRetrieveRecordsByDomainAndTypeWithBody(ctx context.Context, domain DomainPath, recordType string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DnsRetrieveRecordsByDomainAndType(ctx context.Context, domain DomainPath, recordType string, body DnsRetrieveRecordsByDomainAndTypeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DnsRetrieveRecordsByDomainAndTypeAndSubdomainWithBody request with any body
	DnsRetrieveRecordsByDomainAndTypeAndSubdomainWithBody(ctx context.Context, domain DomainPath, recordType string, subdomain string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DnsRetrieveRecordsByDomainAndTypeAndSubdomain(ctx context.Context, domain DomainPath, recordType string, subdomain string, body DnsRetrieveRecordsByDomainAndTypeAndSubdomainJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DomainGetNameServersWithBody request with any body
	DomainGetNameServersWithBody(ctx context.Context, domain DomainPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DomainGetNameServers(ctx context.Context, domain DomainPath, body DomainGetNameServersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DomainListAllWithBody request with any body
	DomainListAllWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DomainListAll(ctx context.Context, body DomainListAllJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DomainUpdateNameServersWithBody request with any body
	DomainUpdateNameServersWithBody(ctx context.Context, domain DomainPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DomainUpdateNameServers(ctx context.Context, domain DomainPath, body DomainUpdateNameServersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) DnsCreateRecordWithBody(ctx context.Context, domain DomainPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDnsCreateRecordRequestWithBody(c.Server, domain, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DnsCreateRecord(ctx context.Context, domain DomainPath, body DnsCreateRecordJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDnsCreateRecordRequest(c.Server, domain, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DnsDeleteRecordByDomainAndIdWithBody(ctx context.Context, domain DomainPath, recordId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDnsDeleteRecordByDomainAndIdRequestWithBody(c.Server, domain, recordId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DnsDeleteRecordByDomainAndId(ctx context.Context, domain DomainPath, recordId string, body DnsDeleteRecordByDomainAndIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDnsDeleteRecordByDomainAndIdRequest(c.Server, domain, recordId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DnsEditRecordByDomainAndIdWithBody(ctx context.Context, domain DomainPath, recordId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDnsEditRecordByDomainAndIdRequestWithBody(c.Server, domain, recordId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DnsEditRecordByDomainAndId(ctx context.Context, domain DomainPath, recordId string, body DnsEditRecordByDomainAndIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDnsEditRecordByDomainAndIdRequest(c.Server, domain, recordId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DnsRetrieveRecordsByDomainWithBody(ctx context.Context, domain DomainPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDnsRetrieveRecordsByDomainRequestWithBody(c.Server, domain, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DnsRetrieveRecordsByDomain(ctx context.Context, domain DomainPath, body DnsRetrieveRecordsByDomainJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDnsRetrieveRecordsByDomainRequest(c.Server, domain, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DnsRetrieveRecordsByDomainAndIdWithBody(ctx context.Context, domain DomainPath, recordId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDnsRetrieveRecordsByDomainAndIdRequestWithBody(c.Server, domain, recordId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DnsRetrieveRecordsByDomainAndId(ctx context.Context, domain DomainPath, recordId string, body DnsRetrieveRecordsByDomainAndIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDnsRetrieveRecordsByDomainAndIdRequest(c.Server, domain, recordId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DnsRetrieveRecordsByDomainAndTypeWithBody(ctx context.Context, domain DomainPath, recordType string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDnsRetrieveRecordsByDomainAndTypeRequestWithBody(c.Server, domain, recordType, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DnsRetrieveRecordsByDomainAndType(ctx context.Context, domain DomainPath, recordType string, body DnsRetrieveRecordsByDomainAndTypeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDnsRetrieveRecordsByDomainAndTypeRequest(c.Server, domain, recordType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DnsRetrieveRecordsByDomainAndTypeAndSubdomainWithBody(ctx context.Context, domain DomainPath, recordType string, subdomain string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDnsRetrieveRecordsByDomainAndTypeAndSubdomainRequestWithBody(c.Server, domain, recordType, subdomain, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DnsRetrieveRecordsByDomainAndTypeAndSubdomain(ctx context.Context, domain DomainPath, recordType string, subdomain string, body DnsRetrieveRecordsByDomainAndTypeAndSubdomainJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDnsRetrieveRecordsByDomainAndTypeAndSubdomainRequest(c.Server, domain, recordType, subdomain, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DomainGetNameServersWithBody(ctx context.Context, domain DomainPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDomainGetNameServersRequestWithBody(c.Server, domain, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DomainGetNameServers(ctx context.Context, domain DomainPath, body DomainGetNameServersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDomainGetNameServersRequest(c.Server, domain, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DomainListAllWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDomainListAllRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DomainListAll(ctx context.Context, body DomainListAllJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDomainListAllRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DomainUpdateNameServersWithBody(ctx context.Context, domain DomainPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDomainUpdateNameServersRequestWithBody(c.Server, domain, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DomainUpdateNameServers(ctx context.Context, domain DomainPath, body DomainUpdateNameServersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDomainUpdateNameServersRequest(c.Server, domain, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewDnsCreateRecordRequest calls the generic DnsCreateRecord builder with application/json body
func NewDnsCreateRecordRequest(server string, domain DomainPath, body DnsCreateRecordJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDnsCreateRecordRequestWithBody(server, domain, "application/json", bodyReader)
}

// NewDnsCreateRecordRequestWithBody generates requests for DnsCreateRecord with any type of body
func NewDnsCreateRecordRequestWithBody(server string, domain DomainPath, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "domain", runtime.ParamLocationPath, domain)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/dns/create/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDnsDeleteRecordByDomainAndIdRequest calls the generic DnsDeleteRecordByDomainAndId builder with application/json body
func NewDnsDeleteRecordByDomainAndIdRequest(server string, domain DomainPath, recordId string, body DnsDeleteRecordByDomainAndIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDnsDeleteRecordByDomainAndIdRequestWithBody(server, domain, recordId, "application/json", bodyReader)
}

// NewDnsDeleteRecordByDomainAndIdRequestWithBody generates requests for DnsDeleteRecordByDomainAndId with any type of body
func NewDnsDeleteRecordByDomainAndIdRequestWithBody(server string, domain DomainPath, recordId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "domain", runtime.ParamLocationPath, domain)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "record_id", runtime.ParamLocationPath, recordId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/dns/delete/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDnsEditRecordByDomainAndIdRequest calls the generic DnsEditRecordByDomainAndId builder with application/json body
func NewDnsEditRecordByDomainAndIdRequest(server string, domain DomainPath, recordId string, body DnsEditRecordByDomainAndIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDnsEditRecordByDomainAndIdRequestWithBody(server, domain, recordId, "application/json", bodyReader)
}

// NewDnsEditRecordByDomainAndIdRequestWithBody generates requests for DnsEditRecordByDomainAndId with any type of body
func NewDnsEditRecordByDomainAndIdRequestWithBody(server string, domain DomainPath, recordId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "domain", runtime.ParamLocationPath, domain)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "record_id", runtime.ParamLocationPath, recordId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/dns/edit/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDnsRetrieveRecordsByDomainRequest calls the generic DnsRetrieveRecordsByDomain builder with application/json body
func NewDnsRetrieveRecordsByDomainRequest(server string, domain DomainPath, body DnsRetrieveRecordsByDomainJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDnsRetrieveRecordsByDomainRequestWithBody(server, domain, "application/json", bodyReader)
}

// NewDnsRetrieveRecordsByDomainRequestWithBody generates requests for DnsRetrieveRecordsByDomain with any type of body
func NewDnsRetrieveRecordsByDomainRequestWithBody(server string, domain DomainPath, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "domain", runtime.ParamLocationPath, domain)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/dns/retrieve/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDnsRetrieveRecordsByDomainAndIdRequest calls the generic DnsRetrieveRecordsByDomainAndId builder with application/json body
func NewDnsRetrieveRecordsByDomainAndIdRequest(server string, domain DomainPath, recordId string, body DnsRetrieveRecordsByDomainAndIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDnsRetrieveRecordsByDomainAndIdRequestWithBody(server, domain, recordId, "application/json", bodyReader)
}

// NewDnsRetrieveRecordsByDomainAndIdRequestWithBody generates requests for DnsRetrieveRecordsByDomainAndId with any type of body
func NewDnsRetrieveRecordsByDomainAndIdRequestWithBody(server string, domain DomainPath, recordId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "domain", runtime.ParamLocationPath, domain)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "record_id", runtime.ParamLocationPath, recordId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/dns/retrieve/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDnsRetrieveRecordsByDomainAndTypeRequest calls the generic DnsRetrieveRecordsByDomainAndType builder with application/json body
func NewDnsRetrieveRecordsByDomainAndTypeRequest(server string, domain DomainPath, recordType string, body DnsRetrieveRecordsByDomainAndTypeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDnsRetrieveRecordsByDomainAndTypeRequestWithBody(server, domain, recordType, "application/json", bodyReader)
}

// NewDnsRetrieveRecordsByDomainAndTypeRequestWithBody generates requests for DnsRetrieveRecordsByDomainAndType with any type of body
func NewDnsRetrieveRecordsByDomainAndTypeRequestWithBody(server string, domain DomainPath, recordType string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "domain", runtime.ParamLocationPath, domain)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "record_type", runtime.ParamLocationPath, recordType)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/dns/retrieveByNameType/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDnsRetrieveRecordsByDomainAndTypeAndSubdomainRequest calls the generic DnsRetrieveRecordsByDomainAndTypeAndSubdomain builder with application/json body
func NewDnsRetrieveRecordsByDomainAndTypeAndSubdomainRequest(server string, domain DomainPath, recordType string, subdomain string, body DnsRetrieveRecordsByDomainAndTypeAndSubdomainJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDnsRetrieveRecordsByDomainAndTypeAndSubdomainRequestWithBody(server, domain, recordType, subdomain, "application/json", bodyReader)
}

// NewDnsRetrieveRecordsByDomainAndTypeAndSubdomainRequestWithBody generates requests for DnsRetrieveRecordsByDomainAndTypeAndSubdomain with any type of body
func NewDnsRetrieveRecordsByDomainAndTypeAndSubdomainRequestWithBody(server string, domain DomainPath, recordType string, subdomain string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "domain", runtime.ParamLocationPath, domain)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "record_type", runtime.ParamLocationPath, recordType)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "subdomain", runtime.ParamLocationPath, subdomain)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/dns/retrieveByNameType/%s/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDomainGetNameServersRequest calls the generic DomainGetNameServers builder with application/json body
func NewDomainGetNameServersRequest(server string, domain DomainPath, body DomainGetNameServersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDomainGetNameServersRequestWithBody(server, domain, "application/json", bodyReader)
}

// NewDomainGetNameServersRequestWithBody generates requests for DomainGetNameServers with any type of body
func NewDomainGetNameServersRequestWithBody(server string, domain DomainPath, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "domain", runtime.ParamLocationPath, domain)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/domain/getNs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDomainListAllRequest calls the generic DomainListAll builder with application/json body
func NewDomainListAllRequest(server string, body DomainListAllJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDomainListAllRequestWithBody(server, "application/json", bodyReader)
}

// NewDomainListAllRequestWithBody generates requests for DomainListAll with any type of body
func NewDomainListAllRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/domain/listAll")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDomainUpdateNameServersRequest calls the generic DomainUpdateNameServers builder with application/json body
func NewDomainUpdateNameServersRequest(server string, domain DomainPath, body DomainUpdateNameServersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDomainUpdateNameServersRequestWithBody(server, domain, "application/json", bodyReader)
}

// NewDomainUpdateNameServersRequestWithBody generates requests for DomainUpdateNameServers with any type of body
func NewDomainUpdateNameServersRequestWithBody(server string, domain DomainPath, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "domain", runtime.ParamLocationPath, domain)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/domain/updateNs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// DnsCreateRecordWithBodyWithResponse request with any body
	DnsCreateRecordWithBodyWithResponse(ctx context.Context, domain DomainPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DnsCreateRecordResp, error)

	DnsCreateRecordWithResponse(ctx context.Context, domain DomainPath, body DnsCreateRecordJSONRequestBody, reqEditors ...RequestEditorFn) (*DnsCreateRecordResp, error)

	// DnsDeleteRecordByDomainAndIdWithBodyWithResponse request with any body
	DnsDeleteRecordByDomainAndIdWithBodyWithResponse(ctx context.Context, domain DomainPath, recordId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DnsDeleteRecordByDomainAndIdResp, error)

	DnsDeleteRecordByDomainAndIdWithResponse(ctx context.Context, domain DomainPath, recordId string, body DnsDeleteRecordByDomainAndIdJSONRequestBody, reqEditors ...RequestEditorFn) (*DnsDeleteRecordByDomainAndIdResp, error)

	// DnsEditRecordByDomainAndIdWithBodyWithResponse request with any body
	DnsEditRecordByDomainAndIdWithBodyWithResponse(ctx context.Context, domain DomainPath, recordId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DnsEditRecordByDomainAndIdResp, error)

	DnsEditRecordByDomainAndIdWithResponse(ctx context.Context, domain DomainPath, recordId string, body DnsEditRecordByDomainAndIdJSONRequestBody, reqEditors ...RequestEditorFn) (*DnsEditRecordByDomainAndIdResp, error)

	// DnsRetrieveRecordsByDomainWithBodyWithResponse request with any body
	DnsRetrieveRecordsByDomainWithBodyWithResponse(ctx context.Context, domain DomainPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DnsRetrieveRecordsByDomainResp, error)

	DnsRetrieveRecordsByDomainWithResponse(ctx context.Context, domain DomainPath, body DnsRetrieveRecordsByDomainJSONRequestBody, reqEditors ...RequestEditorFn) (*DnsRetrieveRecordsByDomainResp, error)

	// DnsRetrieveRecordsByDomainAndIdWithBodyWithResponse request with any body
	DnsRetrieveRecordsByDomainAndIdWithBodyWithResponse(ctx context.Context, domain DomainPath, recordId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DnsRetrieveRecordsByDomainAndIdResp, error)

	DnsRetrieveRecordsByDomainAndIdWithResponse(ctx context.Context, domain DomainPath, recordId string, body DnsRetrieveRecordsByDomainAndIdJSONRequestBody, reqEditors ...RequestEditorFn) (*DnsRetrieveRecordsByDomainAndIdResp, error)

	// DnsRetrieveRecordsByDomainAndTypeWithBodyWithResponse request with any body
	DnsRetrieveRecordsByDomainAndTypeWithBodyWithResponse(ctx context.Context, domain DomainPath, recordType string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DnsRetrieveRecordsByDomainAndTypeResp, error)

	DnsRetrieveRecordsByDomainAndTypeWithResponse(ctx context.Context, domain DomainPath, recordType string, body DnsRetrieveRecordsByDomainAndTypeJSONRequestBody, reqEditors ...RequestEditorFn) (*DnsRetrieveRecordsByDomainAndTypeResp, error)

	// DnsRetrieveRecordsByDomainAndTypeAndSubdomainWithBodyWithResponse request with any body
	DnsRetrieveRecordsByDomainAndTypeAndSubdomainWithBodyWithResponse(ctx context.Context, domain DomainPath, recordType string, subdomain string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DnsRetrieveRecordsByDomainAndTypeAndSubdomainResp, error)

	DnsRetrieveRecordsByDomainAndTypeAndSubdomainWithResponse(ctx context.Context, domain DomainPath, recordType string, subdomain string, body DnsRetrieveRecordsByDomainAndTypeAndSubdomainJSONRequestBody, reqEditors ...RequestEditorFn) (*DnsRetrieveRecordsByDomainAndTypeAndSubdomainResp, error)

	// DomainGetNameServersWithBodyWithResponse request with any body
	DomainGetNameServersWithBodyWithResponse(ctx context.Context, domain DomainPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DomainGetNameServersResp, error)

	DomainGetNameServersWithResponse(ctx context.Context, domain DomainPath, body DomainGetNameServersJSONRequestBody, reqEditors ...RequestEditorFn) (*DomainGetNameServersResp, error)

	// DomainListAllWithBodyWithResponse request with any body
	DomainListAllWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DomainListAllResp, error)

	DomainListAllWithResponse(ctx context.Context, body DomainListAllJSONRequestBody, reqEditors ...RequestEditorFn) (*DomainListAllResp, error)

	// DomainUpdateNameServersWithBodyWithResponse request with any body
	DomainUpdateNameServersWithBodyWithResponse(ctx context.Context, domain DomainPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DomainUpdateNameServersResp, error)

	DomainUpdateNameServersWithResponse(ctx context.Context, domain DomainPath, body DomainUpdateNameServersJSONRequestBody, reqEditors ...RequestEditorFn) (*DomainUpdateNameServersResp, error)
}

type DnsCreateRecordResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Id     int64  `json:"id"`
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r DnsCreateRecordResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DnsCreateRecordResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DnsDeleteRecordByDomainAndIdResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r DnsDeleteRecordByDomainAndIdResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DnsDeleteRecordByDomainAndIdResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DnsEditRecordByDomainAndIdResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r DnsEditRecordByDomainAndIdResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DnsEditRecordByDomainAndIdResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DnsRetrieveRecordsByDomainResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Records []DnsRecord `json:"records"`
		Status  string      `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r DnsRetrieveRecordsByDomainResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DnsRetrieveRecordsByDomainResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DnsRetrieveRecordsByDomainAndIdResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Records []DnsRecord `json:"records"`
		Status  string      `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r DnsRetrieveRecordsByDomainAndIdResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DnsRetrieveRecordsByDomainAndIdResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DnsRetrieveRecordsByDomainAndTypeResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Records []DnsRecord `json:"records"`
		Status  string      `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r DnsRetrieveRecordsByDomainAndTypeResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DnsRetrieveRecordsByDomainAndTypeResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DnsRetrieveRecordsByDomainAndTypeAndSubdomainResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Records []DnsRecord `json:"records"`
		Status  string      `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r DnsRetrieveRecordsByDomainAndTypeAndSubdomainResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DnsRetrieveRecordsByDomainAndTypeAndSubdomainResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DomainGetNameServersResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DomainGetNameServersResponse
}

// Status returns HTTPResponse.Status
func (r DomainGetNameServersResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DomainGetNameServersResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DomainListAllResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DomainListAllResponse
}

// Status returns HTTPResponse.Status
func (r DomainListAllResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DomainListAllResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DomainUpdateNameServersResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r DomainUpdateNameServersResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DomainUpdateNameServersResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// DnsCreateRecordWithBodyWithResponse request with arbitrary body returning *DnsCreateRecordResp
func (c *ClientWithResponses) DnsCreateRecordWithBodyWithResponse(ctx context.Context, domain DomainPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DnsCreateRecordResp, error) {
	rsp, err := c.DnsCreateRecordWithBody(ctx, domain, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDnsCreateRecordResp(rsp)
}

func (c *ClientWithResponses) DnsCreateRecordWithResponse(ctx context.Context, domain DomainPath, body DnsCreateRecordJSONRequestBody, reqEditors ...RequestEditorFn) (*DnsCreateRecordResp, error) {
	rsp, err := c.DnsCreateRecord(ctx, domain, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDnsCreateRecordResp(rsp)
}

// DnsDeleteRecordByDomainAndIdWithBodyWithResponse request with arbitrary body returning *DnsDeleteRecordByDomainAndIdResp
func (c *ClientWithResponses) DnsDeleteRecordByDomainAndIdWithBodyWithResponse(ctx context.Context, domain DomainPath, recordId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DnsDeleteRecordByDomainAndIdResp, error) {
	rsp, err := c.DnsDeleteRecordByDomainAndIdWithBody(ctx, domain, recordId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDnsDeleteRecordByDomainAndIdResp(rsp)
}

func (c *ClientWithResponses) DnsDeleteRecordByDomainAndIdWithResponse(ctx context.Context, domain DomainPath, recordId string, body DnsDeleteRecordByDomainAndIdJSONRequestBody, reqEditors ...RequestEditorFn) (*DnsDeleteRecordByDomainAndIdResp, error) {
	rsp, err := c.DnsDeleteRecordByDomainAndId(ctx, domain, recordId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDnsDeleteRecordByDomainAndIdResp(rsp)
}

// DnsEditRecordByDomainAndIdWithBodyWithResponse request with arbitrary body returning *DnsEditRecordByDomainAndIdResp
func (c *ClientWithResponses) DnsEditRecordByDomainAndIdWithBodyWithResponse(ctx context.Context, domain DomainPath, recordId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DnsEditRecordByDomainAndIdResp, error) {
	rsp, err := c.DnsEditRecordByDomainAndIdWithBody(ctx, domain, recordId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDnsEditRecordByDomainAndIdResp(rsp)
}

func (c *ClientWithResponses) DnsEditRecordByDomainAndIdWithResponse(ctx context.Context, domain DomainPath, recordId string, body DnsEditRecordByDomainAndIdJSONRequestBody, reqEditors ...RequestEditorFn) (*DnsEditRecordByDomainAndIdResp, error) {
	rsp, err := c.DnsEditRecordByDomainAndId(ctx, domain, recordId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDnsEditRecordByDomainAndIdResp(rsp)
}

// DnsRetrieveRecordsByDomainWithBodyWithResponse request with arbitrary body returning *DnsRetrieveRecordsByDomainResp
func (c *ClientWithResponses) DnsRetrieveRecordsByDomainWithBodyWithResponse(ctx context.Context, domain DomainPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DnsRetrieveRecordsByDomainResp, error) {
	rsp, err := c.DnsRetrieveRecordsByDomainWithBody(ctx, domain, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDnsRetrieveRecordsByDomainResp(rsp)
}

func (c *ClientWithResponses) DnsRetrieveRecordsByDomainWithResponse(ctx context.Context, domain DomainPath, body DnsRetrieveRecordsByDomainJSONRequestBody, reqEditors ...RequestEditorFn) (*DnsRetrieveRecordsByDomainResp, error) {
	rsp, err := c.DnsRetrieveRecordsByDomain(ctx, domain, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDnsRetrieveRecordsByDomainResp(rsp)
}

// DnsRetrieveRecordsByDomainAndIdWithBodyWithResponse request with arbitrary body returning *DnsRetrieveRecordsByDomainAndIdResp
func (c *ClientWithResponses) DnsRetrieveRecordsByDomainAndIdWithBodyWithResponse(ctx context.Context, domain DomainPath, recordId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DnsRetrieveRecordsByDomainAndIdResp, error) {
	rsp, err := c.DnsRetrieveRecordsByDomainAndIdWithBody(ctx, domain, recordId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDnsRetrieveRecordsByDomainAndIdResp(rsp)
}

func (c *ClientWithResponses) DnsRetrieveRecordsByDomainAndIdWithResponse(ctx context.Context, domain DomainPath, recordId string, body DnsRetrieveRecordsByDomainAndIdJSONRequestBody, reqEditors ...RequestEditorFn) (*DnsRetrieveRecordsByDomainAndIdResp, error) {
	rsp, err := c.DnsRetrieveRecordsByDomainAndId(ctx, domain, recordId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDnsRetrieveRecordsByDomainAndIdResp(rsp)
}

// DnsRetrieveRecordsByDomainAndTypeWithBodyWithResponse request with arbitrary body returning *DnsRetrieveRecordsByDomainAndTypeResp
func (c *ClientWithResponses) DnsRetrieveRecordsByDomainAndTypeWithBodyWithResponse(ctx context.Context, domain DomainPath, recordType string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DnsRetrieveRecordsByDomainAndTypeResp, error) {
	rsp, err := c.DnsRetrieveRecordsByDomainAndTypeWithBody(ctx, domain, recordType, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDnsRetrieveRecordsByDomainAndTypeResp(rsp)
}

func (c *ClientWithResponses) DnsRetrieveRecordsByDomainAndTypeWithResponse(ctx context.Context, domain DomainPath, recordType string, body DnsRetrieveRecordsByDomainAndTypeJSONRequestBody, reqEditors ...RequestEditorFn) (*DnsRetrieveRecordsByDomainAndTypeResp, error) {
	rsp, err := c.DnsRetrieveRecordsByDomainAndType(ctx, domain, recordType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDnsRetrieveRecordsByDomainAndTypeResp(rsp)
}

// DnsRetrieveRecordsByDomainAndTypeAndSubdomainWithBodyWithResponse request with arbitrary body returning *DnsRetrieveRecordsByDomainAndTypeAndSubdomainResp
func (c *ClientWithResponses) DnsRetrieveRecordsByDomainAndTypeAndSubdomainWithBodyWithResponse(ctx context.Context, domain DomainPath, recordType string, subdomain string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DnsRetrieveRecordsByDomainAndTypeAndSubdomainResp, error) {
	rsp, err := c.DnsRetrieveRecordsByDomainAndTypeAndSubdomainWithBody(ctx, domain, recordType, subdomain, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDnsRetrieveRecordsByDomainAndTypeAndSubdomainResp(rsp)
}

func (c *ClientWithResponses) DnsRetrieveRecordsByDomainAndTypeAndSubdomainWithResponse(ctx context.Context, domain DomainPath, recordType string, subdomain string, body DnsRetrieveRecordsByDomainAndTypeAndSubdomainJSONRequestBody, reqEditors ...RequestEditorFn) (*DnsRetrieveRecordsByDomainAndTypeAndSubdomainResp, error) {
	rsp, err := c.DnsRetrieveRecordsByDomainAndTypeAndSubdomain(ctx, domain, recordType, subdomain, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDnsRetrieveRecordsByDomainAndTypeAndSubdomainResp(rsp)
}

// DomainGetNameServersWithBodyWithResponse request with arbitrary body returning *DomainGetNameServersResp
func (c *ClientWithResponses) DomainGetNameServersWithBodyWithResponse(ctx context.Context, domain DomainPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DomainGetNameServersResp, error) {
	rsp, err := c.DomainGetNameServersWithBody(ctx, domain, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDomainGetNameServersResp(rsp)
}

func (c *ClientWithResponses) DomainGetNameServersWithResponse(ctx context.Context, domain DomainPath, body DomainGetNameServersJSONRequestBody, reqEditors ...RequestEditorFn) (*DomainGetNameServersResp, error) {
	rsp, err := c.DomainGetNameServers(ctx, domain, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDomainGetNameServersResp(rsp)
}

// DomainListAllWithBodyWithResponse request with arbitrary body returning *DomainListAllResp
func (c *ClientWithResponses) DomainListAllWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DomainListAllResp, error) {
	rsp, err := c.DomainListAllWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDomainListAllResp(rsp)
}

func (c *ClientWithResponses) DomainListAllWithResponse(ctx context.Context, body DomainListAllJSONRequestBody, reqEditors ...RequestEditorFn) (*DomainListAllResp, error) {
	rsp, err := c.DomainListAll(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDomainListAllResp(rsp)
}

// DomainUpdateNameServersWithBodyWithResponse request with arbitrary body returning *DomainUpdateNameServersResp
func (c *ClientWithResponses) DomainUpdateNameServersWithBodyWithResponse(ctx context.Context, domain DomainPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DomainUpdateNameServersResp, error) {
	rsp, err := c.DomainUpdateNameServersWithBody(ctx, domain, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDomainUpdateNameServersResp(rsp)
}

func (c *ClientWithResponses) DomainUpdateNameServersWithResponse(ctx context.Context, domain DomainPath, body DomainUpdateNameServersJSONRequestBody, reqEditors ...RequestEditorFn) (*DomainUpdateNameServersResp, error) {
	rsp, err := c.DomainUpdateNameServers(ctx, domain, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDomainUpdateNameServersResp(rsp)
}

// ParseDnsCreateRecordResp parses an HTTP response from a DnsCreateRecordWithResponse call
func ParseDnsCreateRecordResp(rsp *http.Response) (*DnsCreateRecordResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DnsCreateRecordResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Id     int64  `json:"id"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDnsDeleteRecordByDomainAndIdResp parses an HTTP response from a DnsDeleteRecordByDomainAndIdWithResponse call
func ParseDnsDeleteRecordByDomainAndIdResp(rsp *http.Response) (*DnsDeleteRecordByDomainAndIdResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DnsDeleteRecordByDomainAndIdResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDnsEditRecordByDomainAndIdResp parses an HTTP response from a DnsEditRecordByDomainAndIdWithResponse call
func ParseDnsEditRecordByDomainAndIdResp(rsp *http.Response) (*DnsEditRecordByDomainAndIdResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DnsEditRecordByDomainAndIdResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDnsRetrieveRecordsByDomainResp parses an HTTP response from a DnsRetrieveRecordsByDomainWithResponse call
func ParseDnsRetrieveRecordsByDomainResp(rsp *http.Response) (*DnsRetrieveRecordsByDomainResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DnsRetrieveRecordsByDomainResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Records []DnsRecord `json:"records"`
			Status  string      `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDnsRetrieveRecordsByDomainAndIdResp parses an HTTP response from a DnsRetrieveRecordsByDomainAndIdWithResponse call
func ParseDnsRetrieveRecordsByDomainAndIdResp(rsp *http.Response) (*DnsRetrieveRecordsByDomainAndIdResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DnsRetrieveRecordsByDomainAndIdResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Records []DnsRecord `json:"records"`
			Status  string      `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDnsRetrieveRecordsByDomainAndTypeResp parses an HTTP response from a DnsRetrieveRecordsByDomainAndTypeWithResponse call
func ParseDnsRetrieveRecordsByDomainAndTypeResp(rsp *http.Response) (*DnsRetrieveRecordsByDomainAndTypeResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DnsRetrieveRecordsByDomainAndTypeResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Records []DnsRecord `json:"records"`
			Status  string      `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDnsRetrieveRecordsByDomainAndTypeAndSubdomainResp parses an HTTP response from a DnsRetrieveRecordsByDomainAndTypeAndSubdomainWithResponse call
func ParseDnsRetrieveRecordsByDomainAndTypeAndSubdomainResp(rsp *http.Response) (*DnsRetrieveRecordsByDomainAndTypeAndSubdomainResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DnsRetrieveRecordsByDomainAndTypeAndSubdomainResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Records []DnsRecord `json:"records"`
			Status  string      `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDomainGetNameServersResp parses an HTTP response from a DomainGetNameServersWithResponse call
func ParseDomainGetNameServersResp(rsp *http.Response) (*DomainGetNameServersResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DomainGetNameServersResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DomainGetNameServersResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDomainListAllResp parses an HTTP response from a DomainListAllWithResponse call
func ParseDomainListAllResp(rsp *http.Response) (*DomainListAllResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DomainListAllResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DomainListAllResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDomainUpdateNameServersResp parses an HTTP response from a DomainUpdateNameServersWithResponse call
func ParseDomainUpdateNameServersResp(rsp *http.Response) (*DomainUpdateNameServersResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DomainUpdateNameServersResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}
